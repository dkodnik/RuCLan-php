{
	"inc": "<string.h>",
	"lex": {

		"КопироватьЧастьСтроки": {
			"ver": "",
			"org": "memcpy",
			"call_org": "void* memcpy(char* dest, const char* src, size_t n)",
			"call": "",
			"dscrp": "Копирует 'n' байт из области памяти 'src' в 'dest', которые не должны пересекаться, в противном случае результат неопределен (возможно как правильное копирование, так и нет)",
			"demo": ""
		},

		"ПереместитьЧастьСтроки": {
			"ver": "",
			"org": "memmove",
			"call_org": "void* memmove(char* dest, const char* src, size_t n)",
			"call": "",
			"dscrp": "Копирует 'n' байт из области памяти 'src' в 'dest', которые в отличие от memcpy могут перекрываться",
			"demo": ""
		},

		"НайтиСимволВСтроке": {
			"ver": "",
			"org": "memchr",
			"call_org": "void* memchr(const char* s, char c, size_t n)",
			"call": "",
			"dscrp": "Возвращает указатель на первое вхождение 'c' в первых 'n' байтах 's', или %NULL%, если не найдено",
			"demo": ""
		},

		"СравнитьСтроки": {
			"ver": "",
			"org": "memcmp",
			"call_org": "int memcmp(const char* s1, const char* s2, size_t n)",
			"call": "",
			"dscrp": "Сравнивает первые 'n' символов в областях памяти",
			"demo": ""
		},

		"ЗаполнитьСтрокуСимволом": {
			"ver": "",
			"org": "memset",
			"call_org": "void* memset(char* , int z, size_t)",
			"call": "",
			"dscrp": "Заполняет область памяти одним байтом 'z'",
			"demo": ""
		},

		"ОбъеденитьСтроки": {
			"ver": "",
			"org": "strcat",
			"call_org": "char* strcat(char* dest, const char* src)",
			"call": "",
			"dscrp": "Дописывает строку 'src' в конец 'dest'",
			"demo": ""
		},

		"ОбъеденитьСтрокиОгр": {
			"ver": "",
			"org": "strncat",
			"call_org": "char* strncat(char* dest, const char* src, size_t n)",
			"call": "",
			"dscrp": "Дописывает не более 'n' начальных символов строки 'src' (или всю 'src', если ее длина меньше) в конец 'dest'",
			"demo": ""
		},

		"НайтиСимволВСтрокеСНач": {
			"ver": "",
			"org": "strchr",
			"call_org": "char* strchr(const char* , int)",
			"call": "",
			"dscrp": "Ищет символ в строке, начиная с головы и возвращает его адрес, или %NULL% если не найден",
			"demo": ""
		},

		"НайтиСимволВСтрокеСКон": {
			"ver": "",
			"org": "strrchr",
			"call_org": "char* strrchr(const char* , int)",
			"call": "",
			"dscrp": "Ищет символ в строке, начиная с хвоста и возвращает его адрес, или %NULL% если не найден",
			"demo": ""
		},

		"СравнитьСтроки": {
			"ver": "",
			"org": "strcmp",
			"call_org": "int strcmp(const char* , const char* )",
			"call": "",
			"dscrp": "Лексикографическое сравнение строк (возвращает '0', если строки одинаковые, положительное, если первая строка больше, и отрицательное, если меньше)",
			"demo": ""
		},

		"СравнитьСтрокиОгр": {
			"ver": "",
			"org": "strncmp",
			"call_org": "int strncmp(const char* , const char* , size_t)",
			"call": "",
			"dscrp": "Лексикографическое сравнение первых 'n' байтов строк",
			"demo": ""
		},

		"СравнитьСтрокиЯзык": {
			"ver": "",
			"org": "strcoll",
			"call_org": "int strcoll(const char* , const char* )",
			"call": "",
			"dscrp": "Лексикографическое сравнение строк с учетом значения параметра locale, заданного с помощью функции %setlocale%",
			"demo": ""
		},

		"КопироватьСтроку": {
			"ver": "",
			"org": "strcpy",
			"call_org": "char* strcpy(char* toHere, const char* fromHere)",
			"call": "",
			"dscrp": "Копирует строку из одного места в другое",
			"demo": ""
		},

		"КопироватьСтрокуОгр": {
			"ver": "",
			"org": "strncpy",
			"call_org": "char* strncpy(char* toHere, const char* fromHere, size_t n)",
			"call": "",
			"dscrp": "Копирует до 'n' байт строки из одного места в другое",
			"demo": ""
		},

		"ТексСообщенияОшибки": {
			"ver": "",
			"org": "strerror",
			"call_org": "char* strerror(int)",
			"call": "",
			"dscrp": "Возвращает строковое представление сообщения об ошибке %errno% (не потоко-безопасная)",
			"demo": ""
		},

		"ДлинаСтроки": {
			"ver": "",
			"org": "strlen",
			"call_org": "size_t strlen(const char* )",
			"call": "",
			"dscrp": "Возвращает длину строки",
			"demo": ""
		},

		"ПозицияСимволаНеВходящегоИзПодстраки": {
			"ver": "",
			"org": "strspn",
			"call_org": "size_t strspn(const char* s, const char* accept)",
			"call": "",
			"dscrp": "Определяет максимальную длину начальной подстроки, состоящей исключительно из байтов, перечисленных в 'accept'. Другими словами, для строки 's' функция возвращает значение индекса первого символа из числа символов, не входящих в строку 'accept'.",
			"demo": ""
		},

		"ПозицияСимволаВходящегоИзПодстраки": {
			"ver": "",
			"org": "strcspn",
			"call_org": "size_t strcspn(const char* s, const char* reject)",
			"call": "",
			"dscrp": "Определяет максимальную длину начальной подстроки, состоящей исключительно из байтов, не перечисленных в 'reject'. Другими словами, для строки 's' функция возвращает значение индекса первого символа из числа символов, входящих в строку 'reject'.",
			"demo": ""
		},

		"НайтиЛюбойСимволИзСтроки": {
			"ver": "",
			"org": "strpbrk",
			"call_org": "char* strpbrk(const char* s, const char* accept)",
			"call": "",
			"dscrp": "Находит первое вхождение любого символа, перечисленного в 'accept'",
			"demo": ""
		},

		"НайтиСтроку": {
			"ver": "",
			"org": "strstr",
			"call_org": "char* strstr(const char* haystack, const char* needle)",
			"call": "",
			"dscrp": "Находит первое вхождение строки 'needle' в 'haystack'",
			"demo": ""
		},

		"РазбитьНаЛексемы": {
			"ver": "",
			"org": "strtok",
			"call_org": "char* strtok(const char* str1, const char* str2)",
			"call": "",
			"dscrp": "Преобразует строку в последовательность токенов. Не потоко-безопасная, не реентерабельная.  Функция возвращает указатель на следующую лексему в строке, на которую указывает 'str1'. Символы из строки, на которую указывает 'str2', используются как ограничители, определяю­щие лексему. Если лексема не найдена, возвращается %NULL%.\n Во время первого вызова функции в качестве указателя в самом деле используется 'str1'. При последующих вызовах в качестве первого аргумента используется %NULL%. Таким образом вся строка может быть разбита на лексемы.\n Важно понимать, что функция модифицирует строку, на которую указывает 'str1'. Каж­дый раз, когда найдена лексема, на месте, где был найден ограничитель, помещается нулевой символ. Таким образом %strtok% продвигается вдоль строки.\n При каждом вызове %strtok% можно варьировать набор ограничителей.",
			"demo": ""
		},

		"КопироватьСтрокуОгрОттранс": {
			"ver": "",
			"org": "strxfrm",
			"call_org": "size_t strxfrm(char* dest, const char* src, size_t n)",
			"call": "",
			"dscrp": "Создает оттранслированную копию строки, такую, что дословное сравнение ее (%strcmp%) будет эквивалентно сравнению с коллатором.\n Функция используется для копирования до 'n' символов содержимого строки, на которую указывает 'src', в строку, на которую указывает 'dest'. Аргумент 'src' должен быть указателем на строку, оканчивающуюся нулевым символом. В процессе копирования любые национальные символы преобразуются в формат, характерный для конкретной страны. Функция %strxfrm% подобна функции %strncpy%.",
			"demo": ""
		},




		"ДублироватьСтроку": {
			"ver": "",
			"org": "strdup",
			"call_org": "char* strdup(const char* str)",
			"call": "",
			"dscrp": "Создает копию строки и возвращает указатель на нее",
			"demo": ""
		},

		"КопироватьСтрокуСГраницами": {
			"ver": "",
			"org": "strcpy_s",
			"call_org": "errno_t strcpy_s(char* restrict s1, rsize_t s1max, const char* restrict s2)",
			"call": "",
			"dscrp": "Вариант %strcpy% с контролем границ",
			"demo": ""
		},

		"КопироватьЧастьСтрокиСПоследнимБайтом": {
			"ver": "",
			"org": "mempcpy",
			"call_org": "void* mempcpy(void* dest, const void* src, size_t n)",
			"call": "",
			"dscrp": "Вариант %memcpy% с возвратом байта, следующего за последним записанным",
			"demo": ""
		},

		"КопироватьЧастьСтрокиСПрерыванием": {
			"ver": "",
			"org": "memccpy",
			"call_org": "void* memccpy(void* dest, const void* src, int c, size_t n)",
			"call": "",
			"dscrp": "Копирует до 'n' байт из одной области памяти в другую (не должны пересекаться), останавливаясь при встрече символа 'c'",
			"demo": ""
		},

		"КодСообщенияОшибки": {
			"ver": "",
			"org": "strerror_r",
			"call_org": "int* strerror_r(int, char* , size_t)",
			"call": "",
			"dscrp": "Возвращает строковое представление кода ошибки %errno% (потоко-безопасная; небольшая разница в семантике между GNU и XSI/POSIX)",
			"demo": ""
		},

		"КопироватьСтрокуСГраницамиХ2": {
			"ver": "",
			"org": "strlcpy",
			"call_org": "size_t strlcpy(char* dest, const char* src, size_t n)",
			"call": "",
			"dscrp": "Вариант %strcpy% с контролем границ, гарантированно устанавливает в конец строки нулевой символ (безопасная замена стандартной функции %strcpy%). Возвращает размер строки по адресу 'src'.",
			"demo": ""
		},

		"РазбитьНаЛексемыБезопасно": {
			"ver": "",
			"org": "strtok_r",
			"call_org": "char* strtok_r(char* , const char* , char* *)",
			"call": "",
			"dscrp": "Потоко-безопасная реентерабельная версия %strtok%",
			"demo": ""
		},

		"ТексСообщенияОшибкиХ2": {
			"ver": "",
			"org": "strsignal",
			"call_org": "char* strsignal(int sig)",
			"call": "",
			"dscrp": "По аналогии с %strerror%, возвращает строковое представление сигнала 'sig' (не потоко-безопасная)",
			"demo": ""
		},



		"ПУСТОЙ": {
			"ver": "",
			"org": "NULL",
			"call_org": "",
			"call": "",
			"dscrp": "Макрос, расширяющий константу нулевого указателя; то есть константу, представляющую значение указателя, гарантированно указывающего несуществующий адрес объекта в памяти",
			"demo": ""
		},
		"пРазм": {
			"ver": "",
			"org": "size_t",
			"call_org": "",
			"call": "",
			"dscrp": "Беззнаковый целый тип, являющийся типом результата выполнения оператора %sizeof%",
			"demo": ""
		}
	}
}